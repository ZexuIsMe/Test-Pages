---
title: 前端-Flex和Gird
date: 2025-07-02 14:25:43
tags: [Flex, Grid]
categories:
  - 前端
  - 康复训练计划表
  - 页面布局
---

> Q：你了解Flex和Gird布局吗？

A：了解一些，flex一般用于做单行或单列的布局处理，而Gird像是flex的进化型，它适合做网格型布局，比如B站就是用网格布局的做的。

> Q：为什么说flex是一维布局，Grid是二维布局？

A：一维布局是做单行或单列布局处理；二维布局是行和列都做的布局

> Q：他们的区别在哪里？
- 用过这两个后，你会发现他们的布局逻辑是反过来的，flex 布局经常是由元素内部的内容去决定场地，而gird是先决定场地安排，再决定内容
- flex 需要用到轴对齐的方式去调整内容，如比轴心的变化，行内容的对齐方式等等，Gird他一般情况是不做这了操作的，它是按人数完全公平的对分
- flex 会根据宽高自动调整占比，溢出会换行，Gird也能做到这一点，但是Grid可以通过 grid-auto-flow 指定自动填充方向，是行优先还是列优先

> Q：他们分别解决了什么问题？
- 我常用 flex 布局去做对齐方式布局的处理，虽然绝对定位能做，但是 flex 去做对齐方式的布局处理很方便，不用担心定位到哪里的问题。很少用flex去做整体方向的页面布局
- Gird适合去做大方向的布局有一定复杂度的有布局规律的页面，比如B站首页、电商网站；
- 所以他们两个的侧重点完全是不同的。

> Q：Flex布局的常用属性有哪些？他们的作用是什么？
> Q：Gird的 `grid-template-rows`如何使用，`fr`单位的含义是什么？

> Q：flex: 1 是什么意思？由哪些属性组成？

A：如果父级所有的子级都有 `flex: 1`,一般情况下，他会把所有自己挤在一行内且，按个数平均分配子级所拥有的空间，

比如一个子级在设置`flex: 1`前内容+剩余空间有200px的宽度，当设置后，如果子级挤在一行且子级很多，那么他就只剩下内容的宽度了。
 
`flex: 1`由 flex-basics、grow、shrink 三个组成

如果遇到 `flex: 1 1 200px`，你知道这是啥吗？，他们分别是 flex: grow shrink basic

> Q: Grid面对IE11浏览器的兼容问题怎么处理？
>
A：这方面我有通过Caniuse查看过，在全球范围内使用率为0.4%，而我们自己情况可能会高一点，但也不会高太多，毕竟政府、银行、军工等需求他们也是在与时俱进的，故这类问题应该是具体情况具体分析，因为面对这类项目的时候就不大可能是Gird这一个兼容问题。一般情况也就是做一些简单预防措施，优雅降级或者渐进增强

> Q：在 Flex 中，align-items和align-content的区别是什么？分别在什么情况下生效？
> A：`align-items`: 针对单行；`align-content`：针对多行元素；

如果父级一行能处理完子级，就用 items, 如果不能且需要有间隔的垂直分布，那么用content,

随意，一般情况下，items的参数为 center、start、end；content的参数一般为 space-between、space-around

> Q：Grid 中的grid-gap和gap属性有什么关系？如何设置行间距和列间距？
> A：没有关系，都是同一人，grid-gap 原本是网格布局特有的属性，17年后变更为 gap，同时flex、multi-column也可以用了

语法：`gap: 行间距 列间距`，可以单独使用`row-gap`控制行间距，同理`column-gap`控制列间距

> Q：Flex 、Grid 布局在渲染性能方面有什么差异？大规模布局中需要注意些什么？
> A：Flex布局是专注于某行或某列的，所以在渲染时，只需要关注该行或该列的内容的对齐方式，是横轴对齐还是竖轴对齐，用什么对齐方式即可，关注的目标少了，自然开销小。

而网格主句是专注于多行多列的，网格布局需要grid-template-rows/columns: 1fr去计算轨道尺寸，同时计算每个网格行占多少，列占多少，如果遇到合并单元格gird-row/column前面的工作又要重新来一遍，拖拽重绘布局等等操作，这些都是渲染上的开销。

所以，在遇到大规模的布局时，遇到这种网格布局我会考虑两个方案，

一是Intersection Observer做动态加载，当目标内容出现在视窗范围内或者即将出现在视窗范围内时去做内容的加载，内容再多一点的话，会考虑结合虚拟滚动通过占位符的减少渲染开销，

二是考虑把布局缓存下来尽可能的减少重排次数，比如通过设置通用CSS变量 `--grid-col: 3; --grid-col: 4` 等方式提前准备好资源 。

之后再根据情况结合弹性布局去做细致化的一个布局处理，而不是为了使用网格而使用网格为了弹性而使用弹性，导致层层嵌套的问题出现。

> Q：Grid 的grid-template-areas属性有什么优势？是否会影响性能？

A: 它将 `gird-template-rows/columns` 以及 `grid-row/column` 合并到一起方便做布局管理的属性，对每一块区域进行命名，如通过字符串"header header header"表示一行3列，且三列是一个合并列，它增加了代码的可读性，

配合对子级添加 `grid-area` 让 `grid-template-areas` 发挥其效用，也可与 `gird-template-rows/column`是 混合使用，增加布局能力，对常规布局来说这样布局会方便快捷许多，适合去静态布局。

如果频繁修改`grid-template-areas`会导致重绘、重排的情况发生，和频繁修改 `gird-template-rows/column`带来的性能开销相差无几的。对于静态布局，使用该属性反而可能提高代码可维护性。就现在2025年的浏览器而言，这方面除非碰到高频修改的操作，不然几乎可以选择性的无视了。

Q：CSS subgird你了解多少？

A：subgird可以继承父级网格布局，让同一级的兄弟元素都保持在一个设计高度，他在一定程度解决了网格布局嵌套网格布局的问题，避免嵌套网格布局带来的渲染性能上的开销，虽然对于现在的浏览器而言，除非高频的修改或者渲染操作，否则基本上可以选择性的无视。

比如说博客网站中文章卡片，一行显示3、5篇文章，但是文章标题，内容几乎是不可控的，就会导致卡片内容乘次不齐，

以前可能会通过`marign:atuo`、`overflow`、`text-overflow:ellipsis`、flex弹性布局等等方法去操作，而现在通过 `subgird` 就可以在很大程度上解决这个问题，让卡片内容始终保持一致。

它的语法：grid-template-rows/columns: subgrid；表示继承父级的行或列的网格情况

比如子级有标题，副标题和内容三个DIV，为了让卡片保持一致性，你需要做的事情就是为子级添加`display: grid; grid-template-rows: subgrid;` 做完这一步，你会发现内容重叠在一起了，根本原因是没有为子级元素分配网格导致的。

所以可以通过`grid-row: span 3;` 去解决这个问题，我们的目标基本上是实现了。无论内容高度是100px还是200px，所有的都是相同的高度。

## Flex 布局
<style>
.post-flex-container {
width: 100%;
display: flex;
flex-wrap: wrap;
justify-content: between;
gap: 30px;
}

.post-flex-item {
  width: 30%;
  height: 50px;
  background-color: var(--info);
display: flex;
justify-content: center;
align-items: center;
font-size: 3rem;
color: var(--white)
}
</style>
<div class="post-flex-container">
  <div class="post-flex-item">1</div>
  <div class="post-flex-item">2</div>
  <div class="post-flex-item">3</div>
  <div class="post-flex-item">4</div>
  <div class="post-flex-item">5</div>
  <div class="post-flex-item">6</div>
  <div class="post-flex-item">7</div>
  <div class="post-flex-item">8</div>
  <div class="post-flex-item">9</div>
  <div class="post-flex-item">10</div>
</div>

<div class="p-4"></div>
Flex可以根据情况自动调整显示的内容，当页面过窄，无需再原本CSS的基础上做改动就会自动换行。是好事也是坏事，

好事：自己无需操心自适应问题

坏事：一旦没把控好，页面在小屏上的呈现力就会很差，而且也没有必要去为了故意造成的情况特地做布局，比如谁家好人会用200*300的宽高浏览网页，但是这确实是会带来很不好浏览体验。所以需要更多的额外属性来确保体验

```html
<style>
.post-flex-container {
width: 100%;
display: flex;
flex-wrap: wrap;
justify-content: space-between;
gap: 30px;
}

.post-flex-item {
  width: 30%;
  height: 50px;
  background-color: var(--info);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 3rem;
color: var(--white)
}
</style>
<div class="post-flex-container">
  <div class="post-flex-item">1</div>
  <div class="post-flex-item">2</div>
  <div class="post-flex-item">3</div>
  <div class="post-flex-item">4</div>
  <div class="post-flex-item">5</div>
  <div class="post-flex-item">6</div>
  <div class="post-flex-item">7</div>
  <div class="post-flex-item">8</div>
  <div class="post-flex-item">9</div>
  <div class="post-flex-item">10</div>
</div>
```

## Grid 布局

<style>
.post-container {
  width: 100%;
  height: 512px;
  display: grid;
  grid-template-rows: repeat(3, 1fr);
  grid-template-columns: repeat(4, minmax(200px, 1fr)) ;
  gap: 1rem;
  overflow: auto;
}

.post-item {
  border-radius: 8px;
  background-color: var(--info);

  display: flex;
  justify-content: center;
  align-items: center;
  color: white;
  font-size:48px
}
</style>

<div class="post-container">
  <div class="post-item">1</div>
  <div class="post-item">2</div>
  <div class="post-item">3</div>
  <div class="post-item">4</div>
  <div class="post-item">5</div>
  <div class="post-item">6</div>
  <div class="post-item">7</div>
  <div class="post-item">8</div>
  <div class="post-item">9</div>
  <div class="post-item">10</div>
</div>

<div class="p-4"></div>
Grid能做到最大程度的按照要求做响应式布局，所示3行4列就是3行4列，不会变，

即便小屏，如果触及到最低布局限制，就不会在做退让

比如：`minmax(200px, 1fr)：grid-template-columns: repeat(4, minmax(200px, 1fr))`

它就让列的宽度，最小为200px，能布局的完整度和体验做到最大提升；<mask>但需要留意的是遇到小屏容易溢出</mask>，那怎么办？看下面的完全响应式布局

```html
<style>
.post-container {
  width: 100%;
  height: 512px;
  display: grid;
  grid-template-rows: repeat(3, 1fr);
  grid-template-columns: repeat(4, 1fr);
  gap: 1rem
}

.post-item {
  border-radius: 8px;
  background-color: var(--info);

  display: flex;
  justify-content: center;
  align-items: center;
  color: white;
  font-size:48px
}
</style>

<div class="post-container">
  <div class="post-item">1</div>
  <div class="post-item">2</div>
  <div class="post-item">3</div>
  <div class="post-item">4</div>
  <div class="post-item">5</div>
  <div class="post-item">6</div>
  <div class="post-item">7</div>
  <div class="post-item">8</div>
  <div class="post-item">9</div>
  <div class="post-item">10</div>
</div>
```

### Gird: 完全响应式布局

几列几行，最大做少，最小多少，均让gird自己控制

<style>
.post-container-2 {
  width: 100%;
  display: grid;
  grid-template-rows: repeat(auto-fill, 1fr);
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)) ;
  gap: 1rem;
}
</style>
<div class="post-container-2">
  <div class="post-item">1</div>
  <div class="post-item">2</div>
  <div class="post-item">3</div>
  <div class="post-item">4</div>
  <div class="post-item">5</div>
  <div class="post-item">6</div>
  <div class="post-item">7</div>
  <div class="post-item">8</div>
  <div class="post-item">9</div>
  <div class="post-item">10</div>
</div>

```css
.post-container-2 {
  width: 100%;
  height: 512px;
  display: grid;
  grid-template-rows: repeat(auto-fill, 1fr);
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)) ;
  gap: 1rem;
}
```

- **核心出装：repeat(auto-fill, minmax(200px, 1fr))**
    - auto-fill：表示自动填充，怎么个自动填充法，按占比去自动填充，给 1fr,就占满；给1fr 1fr 就对半二分
    - minmax(200px; 1fr)：用三元运算符表示就是 screenWidth > 200px ? 1fr : 200px

有一个很有意思的地方，如果你把 two 替换为 one，你会发现 5号位置到第一列第一行了，这个操作就很有意思了

### Grid: 合并单元格

<style>
.post-container-3 {
  width: 100%;
  display: grid;
  grid-template-rows: repeat(auto-fill, 1fr);
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)) ;
  gap: 1rem;
}
.post-container-3 .one {
    /*grid-column: 1/3;*/
    /*grid-row: 1/3;*/
    grid-area: 1/1/3/3
}
.post-container-3 .two {
    grid-column: 3/5
}
</style>

<div class="post-container-3">
  <div class="post-item one">1</div>
  <div class="post-item">2</div>
  <div class="post-item">3</div>
  <div class="post-item">4</div>
  <div class="post-item two">5</div>
  <div class="post-item">6</div>
  <div class="post-item">7</div>
  <div class="post-item">8</div>
  <div class="post-item">9</div>
  <div class="post-item">10</div>
</div>

```html
<style>
.post-container-3 .one {
    /*grid-column: 1/3;*/
    /*grid-row: 1/3;*/
    grid-area: 1/1/3/3
}
.post-container-3 .two {
    grid-column: 3/5
}
</style>

<div class="post-container-3">
  <div class="post-item one">1</div>
  <div class="post-item">2</div>
  <div class="post-item">3</div>
  <div class="post-item">4</div>
  <div class="post-item two">5</div>
  <div class="post-item">6</div>
  <div class="post-item">7</div>
  <div class="post-item">8</div>
  <div class="post-item">9</div>
  <div class="post-item">10</div>
</div>
```

<div class="p-4"></div>

**核心出装：grid-column/row: 1/3**

> Q：grid-column: 1/3 ？

  A：语法：` grid-column: <column-start> / <column-end>`；在这段代码中，1表示起始列，3表示结束列，表示从第一列的最左边开始，到第三列的最左边结束，把之间的空间合并到一起；

> Q：grid-area: 1/1/3/3？

  A：语法：` grid-area: <row-start> / <column-start> / <row-end> / <column-end>` 
  
## Grid: subgird

subgird 能让相同的元素布局保持一致性，比如例子中的【副标题】【内容】，他们内容即变多了，同为一行的元素始终保持一样的高度。

<style>
.grid-subgrid {
  display: grid;
  grid-gap: 10px;
  grid-template-rows: repeat(auto-fill, 1fr);
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
}

.gs-item {
  background-color: var(--grey-100);
  border-radius: 8px;
  display: grid;
  grid-template-rows: subgrid;
  grid-row: span 3;
}
</style>

<section class="grid-subgrid"></section>

<script>
const gsDOM = `
  <div class="gs-item">
    <div>标题</div>
    <div>副标题</div>
    <div>内容</div>
  </div>
`;
const sectionDOM_GridSubgrid = document.querySelector('.grid-subgrid');
for (let i = 0; i < new Array(17).length; i++) {

  switch (i) {
    case 1:
      sectionDOM_GridSubgrid.innerHTML += `
        <div class="gs-item">
          <div>标题</div>
          <div>副标题副标题副标题副标题副标题副标题副标题副标题副标题副标题副标题副标题副标题副标题副标题副标题</div>
          <div>内容</div>
        </div>
      `;
      break;
    case 2:
      sectionDOM_GridSubgrid.innerHTML += `
        <div class="gs-item">
          <div>标题</div>
          <div>副标题</div>
          <div>内容内容内容内容内容内容内容内容内容内容内容内容内容</div>
        </div>
      `;
      break;
    default:
      sectionDOM_GridSubgrid.innerHTML += gsDOM;
  }
}
</script>

```css
.grid-subgrid {
  display: grid;
  grid-gap: 10px;
  grid-template-rows: repeat(3, 1fr);
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
}

.gs-item {
  background-color: var(--grey-100);
  border-radius: 8px;
  display: grid;
  grid-template-rows: subgrid;
  grid-row: span 3;
}
```
```html
<section class="grid-subgrid"></section>
```
```javascript
const gsDOM = `
  <div class="gs-item">
    <div>标题</div>
    <div>副标题</div>
    <div>内容</div>
  </div>
`;
const sectionDOM_GridSubgrid = document.querySelector('.grid-subgrid');
for (let i = 0; i < new Array(17).length; i++) {

  switch (i) {
    case 1:
      sectionDOM_GridSubgrid.innerHTML += `
        <div class="gs-item">
          <div>标题</div>
          <div>副标题副标题副标题副标题副标题副标题副标题副标题副标题副标题副标题副标题副标题副标题副标题副标题</div>
          <div>内容</div>
        </div>
      `;
      break;
    case 2:
      sectionDOM_GridSubgrid.innerHTML += `
        <div class="gs-item">
          <div>标题</div>
          <div>副标题</div>
          <div>内容内容内容内容内容内容内容内容内容内容内容内容内容</div>
        </div>
      `;
      break;
    default:
      sectionDOM_GridSubgrid.innerHTML += gsDOM;
  }
}
```